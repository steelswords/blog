<!doctype html><html data-theme=dark lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://tristanandrus.com name=base><title>Tristan Andrus â€¢ Shrinking the binary size of Rust programs</title><link href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 105 55"><text y=".7em" font-size="82">ðŸ’»</text></svg>' rel=icon><link title="Tristan Andrus - Atom Feed" href=https://tristanandrus.com/atom.xml rel=alternate type=application/atom+xml><link href="https://tristanandrus.com/spoilersection.css?h=a8f027ae57acf043de52" rel=stylesheet><link href="https://tristanandrus.com/attributedblockquote.css?h=1b96ca8639a3c4a94489" rel=stylesheet><link href="https://tristanandrus.com/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://tristanandrus.com/main.css?h=4a3dff148c520f191505" rel=stylesheet><meta content=dark name=color-scheme><meta content="Rust is a performant language. But its binaries are huge. How can we shrink them?" name=description><meta content="Rust is a performant language. But its binaries are huge. How can we shrink them?" property=og:description><meta content="index, nofollow" name=robots><meta content="Shrinking the binary size of Rust programs" property=og:title><meta content=article property=og:type><meta content=en_GB property=og:locale><meta content=https://tristanandrus.com/blog/small-programs-in-rust/ property=og:url><meta content="Tristan Andrus" property=og:site_name><meta content="default-src 'self';font-src 'self' data:;img-src 'self' https://* data:;style-src 'self';frame-src player.vimeo.com https://www.youtube-nocookie.com;connect-src 'self';script-src 'self' 'self'" http-equiv=Content-Security-Policy><script defer src=https://tristanandrus.com/js/toggle_spoiler.js></script><body><header><nav class=navbar><div class=nav-title><a class=home-title href=https://tristanandrus.com>Tristan Andrus</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://tristanandrus.com/experience/> experience </a><li><a class="nav-links no-hover-padding" href=https://tristanandrus.com/blog/> blog </a><li><a class="nav-links no-hover-padding" href=https://tristanandrus.com/tags/> tags </a><li><a class="nav-links no-hover-padding" href=https://tristanandrus.com/archive/> archive </a></li><div class=nav-navs id=menu-icons-group></div></ul></div></nav></header><div class=content><main><article><h1 class=article-title>Shrinking the binary size of Rust programs</h1><ul class=meta><li>17th Jul 2023<li title="899 words"><span aria-hidden=true class=separator>â€¢</span>5 min read<li class=tag><span aria-hidden=true class=separator>â€¢</span>Tags:Â <li class=tag><a href=https://tristanandrus.com/tags/opinion/>opinion</a>,Â <li class=tag><a href=https://tristanandrus.com/tags/rust/>rust</a></ul><section class=body><p>Last week I was discussing with a coworker the merits of Rust versus the enthroned leaders of systems programming: C and C++. I mentioned I had been building a program in Rust to handle some JSON processing over HTTPS. Rust rocks! With its packages, I was able to get a bunch of functionality practically for free: HTTPS, authentication guards (thanks, <code>rocket</code>), JSON parsing (thanks, <code>serde</code> and <code>serde_json</code>), and many other features. But when I mentioned that the release binary was about 13 MB, he pounced and said that would be much smaller if I were developing for an embedded target and not for a Linux environment.<p>I thought that sounded strange. Why would Rust be bloating my binaries? Wasn't efficiency one of the huge draws of Rust for systems programmers like me? What on Earth was going into my binaries?<p>My first erroneous assumption was that only the routines that Rust needs from the standard library and libc would be statically linked into the binary. There I was wrong on two accounts. First, Rust binaries by default are statically linked, but not to libc, just to the Rust code they interface with, the rust std library, etc.<p>Here we take the default "Hello, world" program cargo creates and see what it's linked to:<pre class="language-bash z-code" data-lang=bash><code class=language-bash data-lang=bash><span class="z-source z-shell z-bash"><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">cargo</span></span><span class="z-meta z-function-call z-arguments z-shell"> new small_hello_world</span>
</span><span class="z-source z-shell z-bash"><span class="z-meta z-function-call z-shell"><span class="z-support z-function z-cd z-shell">cd</span></span><span class="z-meta z-function-call z-arguments z-shell"> small_hello_world</span>
</span><span class="z-source z-shell z-bash">
</span><span class="z-source z-shell z-bash"><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">cargo</span></span><span class="z-meta z-function-call z-arguments z-shell"> build<span class="z-variable z-parameter z-option z-shell"><span class="z-punctuation z-definition z-parameter z-shell"> --</span>release</span></span>
</span><span class="z-source z-shell z-bash"><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">ldd</span></span><span class="z-meta z-function-call z-arguments z-shell"> target/release/small_hello_world</span>
</span></code></pre><p>And we get the usual suspects.<pre class=z-code><code><span class="z-text z-plain">linux-vdso.so.1 (0x00007fff21bfe000)
</span><span class="z-text z-plain">libgcc_s.so.1 => /usr/lib/libgcc_s.so.1 (0x00007f9ec5d9c000)
</span><span class="z-text z-plain">libc.so.6 => /usr/lib/libc.so.6 (0x00007f9ec5bb2000)
</span><span class="z-text z-plain">/lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007f9ec5e57000)
</span></code></pre><p>But when we <code>ll</code> it, we see it is 4.1 MB. What on Earth is taking up all that room?<p>By comparison, here are the sizes of the same "Hello, world" program in C, C++, and assembly (see <a href=https://github.com/steelswords/assembly-playground rel=noopener target=_blank>my Github</a> for the asm code):<table><thead><tr><th>Language<th>Program Size<tbody><tr><td>C<td>15,416 bytes<tr><td>C++<td>15,896 bytes<tr><td>Assembly<td>15,520 bytes</table><p>Yes, you saw that right. The assembly program is <strong>larger</strong> than my C program. Perhaps we'll explore this another time. And the extra 15 KB of linked in gunk is a little surprising for such bare-bones languages.<p>But why is the Rust program still 269 times larger?<p>It turns out rust-lang.org has a <a href=https://tristanandrus.com/blog/small-programs-in-rust/FAQ>https://prev.rust-lang.org/en-US/faq.html#why-do-rust-programs-have-larger-binary-sizes-than-C-programs</a> that talks about this very topic. There are several reasons why Rust programs are bigger.<p>First, is monomorphization. Like C++ templates, generic functions and types are generated for each time it's used concretely in the program. This doesn't affect our hello world program at all, but it's nice to know.<p>Second, debug symbols and panic unwinding. Even in release mode, Rust includes the debug symbols to make backtraces during panics worthwhile. When programs are linked with the Rust standard library, they also are linked against <code>libbacktrace</code> and <code>libunwind</code>, which add more overhead. You can get rid of these libraries by not using <code>#![no_std]</code>, but that raises its own set of difficulties.<p>Third, Rust does not do link-time optimization by default. This means larger binaries.<p>Fourth, Rust defaults to an allocator called jemalloc, which apprarently increases the performance and reliability of your garden-variety system allocator. I don't know much more about this facet.<p>Still, let's start disabling those things.<h1 id=shrinking-the-binary><a aria-label="Anchor link for: shrinking-the-binary" class="header-anchor no-hover-padding" href=#shrinking-the-binary><span aria-hidden=true class=link-icon></span></a> Shrinking the Binary</h1><p>Let's strip the debug symbols by using <code>strip</code>:<pre class=z-code><code><span class="z-text z-plain">strip -o hello-world-stripped small_hello_world
</span></code></pre><p>Alright, that got us down to 321,848 bytes. That's amazing! A whole order of magnitude smaller. Now we've just got to shrink it by a factor of 20 or so.<p>As a nice touch (yay, Rust tooling!), you can automatically set up the <code>release</code> profile of your <code>Cargo.toml</code> to strip the debug symbols out:<pre class="language-toml z-code" data-lang=toml><code class=language-toml data-lang=toml><span class="z-source z-toml"><span class="z-punctuation z-definition z-table z-begin z-toml">[</span><span class="z-meta z-tag z-table z-toml"><span class="z-entity z-name z-table z-toml">profile</span><span class="z-punctuation z-separator z-table z-toml">.</span><span class="z-entity z-name z-table z-toml">release</span></span><span class="z-punctuation z-definition z-table z-end z-toml">]</span>
</span><span class="z-source z-toml"><span class="z-meta z-tag z-key z-toml"><span class="z-entity z-name z-tag z-toml">strip</span></span> <span class="z-punctuation z-definition z-key-value z-toml">=</span> <span class="z-constant z-language z-toml">true</span>
</span></code></pre><p>This is thanks to <a href=https://github.com/johnthagen/min-sized-rust rel=noopener target=_blank>johnthagen's wonderful guide on shrinking Rust programs</a>, which informs much of this article.<p>(For those curious, this gives me the same size as manually <code>strip</code>ing the binary afterwards).<p>We will save using <code>no_std</code> for later. For now, let's see what happens if we optimize for size:<pre class="language-toml z-code" data-lang=toml><code class=language-toml data-lang=toml><span class="z-source z-toml"><span class="z-punctuation z-definition z-table z-begin z-toml">[</span><span class="z-meta z-tag z-table z-toml"><span class="z-entity z-name z-table z-toml">profile</span><span class="z-punctuation z-separator z-table z-toml">.</span><span class="z-entity z-name z-table z-toml">release</span></span><span class="z-punctuation z-definition z-table z-end z-toml">]</span>
</span><span class="z-source z-toml"><span class="z-meta z-tag z-key z-toml"><span class="z-entity z-name z-tag z-toml">strip</span></span> <span class="z-punctuation z-definition z-key-value z-toml">=</span> <span class="z-constant z-language z-toml">true</span>
</span><span class="z-source z-toml"><span class="z-meta z-tag z-key z-toml"><span class="z-entity z-name z-tag z-toml">opt-level</span></span> <span class="z-punctuation z-definition z-key-value z-toml">=</span> <span class="z-string z-quoted z-double z-basic z-toml"><span class="z-punctuation z-definition z-string z-begin z-toml">"</span>z<span class="z-punctuation z-definition z-string z-end z-toml">"</span></span>
</span></code></pre><p>Same size. I guess there's not much to shrink down. But how about Link Time Optimization? By default, the Cargo compiles and optimizes each compilation unit separately. Link time optimization, <a href=https://llvm.org/docs/LinkTimeOptimization.html rel=noopener target=_blank>described here</a>, takes longer in the link step, but can produce better optimized binaries with less dead code. We can enable it by adding <code>lto = true</code> in our <code>profile.release</code> section of <code>Cargo.toml</code>.<p>Note that this brought my build time from 0.12 s to 3.86 s; quite the jump. But it also cut about 100 KB from our binary. The size is now 280,888 bytes. But can we get it down further?<p>Let's restrict the number of code generation units. By default, Cargo spins up multiple codegen units to speed up compile times, but that does limit some of the optimizations you can do. Add <code>codegen-units = 1</code> to the <code>profile.release</code> section.<p>Unfortunately, that didn't affect the size at all. And it bumped my build time up to 8.15 s.<p>Let's try disabling some of the nicer features of Rust's <code>panic!</code> calls. By default, a panic unwinds the stack frame and prints a backtrace. But we can strip that feature down by causing panic to abort immediately instead of producing a backtrace. To do this, add <code>panic = "abort"</code> to the same section as above.<p>The good news is that reclaimed about 4KB. We're at 276,792 bytes now.<p>The bad news is that is the end of the easy modifications. The rest of the suggestions involve optimizing <code>libstd</code> for size and taking <code>libstd</code> out altogether. These are projects for a different day.</section></article></main><span class=hidden id=copy-success> Copied! </span><span class=hidden id=copy-init> Copy code to clipboard </span><script defer src=https://tristanandrus.com/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" href=https://tristanandrus.com/atom.xml rel=noopener target=_blank> <img alt=feed loading=lazy src=https://tristanandrus.com/social_icons/rss.svg title=feed> </a><li><a class="nav-links no-hover-padding social" rel="noopener me" href=https://github.com/steelswords/ target=_blank> <img alt=github loading=lazy src=https://tristanandrus.com/social_icons/github.svg title=github> </a><li><a class="nav-links no-hover-padding social" rel="noopener me" href=https://www.linkedin.com/in/tristan-andrus target=_blank> <img alt=linkedin loading=lazy src=https://tristanandrus.com/social_icons/linkedin.svg title=linkedin> </a><li><a class="nav-links no-hover-padding social" rel="noopener me" href=https://fosstodon.org/@steelswords target=_blank> <img alt=mastodon loading=lazy src=https://tristanandrus.com/social_icons/mastodon.svg title=mastodon> </a><li><a class="nav-links no-hover-padding social" rel="noopener me" href=https://bsky.app/profile/steelswords.bsky.social target=_blank> <img alt=bluesky loading=lazy src=https://tristanandrus.com/social_icons/bluesky.svg title=bluesky> </a></ul></nav><nav class=nav-navs></nav><div class=credits><small> Powered by <a href=https://www.getzola.org rel=noopener target=_blank>Zola</a> & <a href=https://github.com/welpo/tabi rel=noopener target=_blank>tabi</a> </small></div></section></footer>