<!doctype html><html data-theme=dark lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://tristanandrus.com name=base><title>Tristan Andrus â€¢ Bare Metal Programming the STM32</title><link href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 105 55"><text y=".7em" font-size="82">ðŸ’»</text></svg>' rel=icon><link title="Tristan Andrus - Atom Feed" href=https://tristanandrus.com/atom.xml rel=alternate type=application/atom+xml><link href="https://tristanandrus.com/spoilersection.css?h=a8f027ae57acf043de52" rel=stylesheet><link href="https://tristanandrus.com/attributedblockquote.css?h=1b96ca8639a3c4a94489" rel=stylesheet><link href="https://tristanandrus.com/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://tristanandrus.com/main.css?h=4a3dff148c520f191505" rel=stylesheet><meta content=dark name=color-scheme><meta content="Programming an ARM Cortex M4 without any framework or IDE - just some datasheets and gcc" name=description><meta content="Programming an ARM Cortex M4 without any framework or IDE - just some datasheets and gcc" property=og:description><meta content="index, nofollow" name=robots><meta content="Bare Metal Programming the STM32" property=og:title><meta content=article property=og:type><meta content=en_GB property=og:locale><meta content=https://tristanandrus.com/blog/bare-metal-arm-programming/ property=og:url><meta content="Tristan Andrus" property=og:site_name><meta content="default-src 'self';font-src 'self' data:;img-src 'self' https://* data:;style-src 'self';frame-src player.vimeo.com https://www.youtube-nocookie.com;connect-src 'self';script-src 'self' 'self'" http-equiv=Content-Security-Policy><script defer src=https://tristanandrus.com/js/toggle_spoiler.js></script><body><header><nav class=navbar><div class=nav-title><a class=home-title href=https://tristanandrus.com>Tristan Andrus</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://tristanandrus.com/experience/> experience </a><li><a class="nav-links no-hover-padding" href=https://tristanandrus.com/blog/> blog </a><li><a class="nav-links no-hover-padding" href=https://tristanandrus.com/tags/> tags </a><li><a class="nav-links no-hover-padding" href=https://tristanandrus.com/archive/> archive </a></li><div class=nav-navs id=menu-icons-group></div></ul></div></nav></header><div class=content><main><article><h1 class=article-title>Bare Metal Programming the STM32</h1><ul class=meta><li>31st Aug 2024<li title="1722 words"><span aria-hidden=true class=separator>â€¢</span>9 min read<li class=tag><span aria-hidden=true class=separator>â€¢</span>Tags:Â <li class=tag><a href=https://tristanandrus.com/tags/bare-metal/>bare-metal</a></ul><section class=body><h1 id=background><a aria-label="Anchor link for: background" class="header-anchor no-hover-padding" href=#background><span aria-hidden=true class=link-icon></span></a> Background</h1><p>My microcontrollers class in my undergraduate degree used the <a href=https://www.st.com/content/ccc/resource/technical/document/datasheet/c5/ed/2f/60/aa/79/42/0b/DM00108832.pdf/files/DM00108832.pdf/jcr:content/translations/en.DM00108832.pdf rel=noopener target=_blank>STM32L476-DISCOVERY</a> for everything. It's a development board with an ARM Cortex-M and a bunch of peripherals. I loved that thing. I've written UART and LCD drivers by interacting with raw registers, set up peripherals using just assembly, controlled a robot over Bluetooth, you name it. But now it's just sitting around, collecting dust. When I wrote code for class, I only ever used the pre-installed, pre-configured Keil IDE the lab had set up. That changes with this project. <strong>I want to program this thing with nothing more than a datasheet and gcc</strong>.<p>I had attempted this once before unsuccessfully, but since then I have found <a href=https://github.com/cpq/bare-metal-programming-guide rel=noopener target=_blank>this remarkable resource by cpq</a>. It details fairly closely what I wanted to do. It helped fill in gaps in my knowledge about the process, but I still had to look up and find lots of details in my datasheets since I was using a different (and much older) processor than in the tutorial.<h1 id=downloading-requisite-software><a aria-label="Anchor link for: downloading-requisite-software" class="header-anchor no-hover-padding" href=#downloading-requisite-software><span aria-hidden=true class=link-icon></span></a> Downloading Requisite Software</h1><p>First thing's first, let's get some software. I needed<ul><li>gcc-arm-none-eabi<li>STLink</ul><h1 id=the-procedure><a aria-label="Anchor link for: the-procedure" class="header-anchor no-hover-padding" href=#the-procedure><span aria-hidden=true class=link-icon></span></a> The Procedure</h1><p>The procedure for bare-metal ARM programming is this:<ol><li>Look at the datasheet to see where the flash is memory mapped.<li>Look at the datasheet to see where the RAM is mapped in memory too.<li>Start looking at memory-mapped peripherals and start <code>#define</code>-ing their pointers and making a nice C interface into them.<li>Make a vector table to go at the beginning of flash memory.</ol><p>Important points:<ul><li>All ARM MCUs reads a "vector table" from the beginning of flash when it boots<li>Vector tables are common to all ARM MCUs<li>A vector table contains entries of 32-bit pointers to functions.<li>The first 16 entries are common to all MCUs.<li>All subsequent entries are used to support peripherals, and so they vary from processor to processor.<li>The <strong>first two entries</strong> in the vector table are very important. They are the <strong>initial stack pointer</strong> (which should point to the end of RAM, I believe. On ARM, the stack lives at the end of RAM and growns downward) and the <strong>address to the boot function, aka entry point</strong>.</ul><p>The trickiest part for the uninitiated is probably going to be writing the linker script. If you can, use a premade one (like the one below) and modify it.<h1 id=execution><a aria-label="Anchor link for: execution" class="header-anchor no-hover-padding" href=#execution><span aria-hidden=true class=link-icon></span></a> Execution</h1><p>So after defining a <code>_reset</code> handler, writing a linker script to put the interrupt vector at the beginning of your binary, and filling out a bare-bones <code>main.c</code>, we have this:<p><strong>main.c</strong>:<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-source z-c"><span class="z-storage z-type z-c">int</span> <span class="z-meta z-function z-c"><span class="z-entity z-name z-function z-c">main</span></span><span class="z-meta z-function z-parameters z-c"><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function z-parameters z-c"><span class="z-meta z-group z-c"><span class="z-storage z-type z-c">void</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span>
</span><span class="z-source z-c">
</span><span class="z-source z-c"><span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> Startup code
</span></span><span class="z-source z-c"><span class="z-meta z-attribute z-c"><span class="z-storage z-modifier z-c">__attribute__</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">((</span></span></span><span class="z-meta z-attribute z-c"><span class="z-meta z-group z-c">naked, noreturn</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">))</span></span></span>
</span><span class="z-source z-c"><span class="z-storage z-type z-c">void</span> <span class="z-meta z-function z-c"><span class="z-entity z-name z-function z-c">_reset</span></span><span class="z-meta z-function z-parameters z-c"><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function z-parameters z-c"><span class="z-meta z-group z-c"><span class="z-storage z-type z-c">void</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-meta z-function z-c">
</span></span><span class="z-source z-c"><span class="z-meta z-function z-c"></span><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-punctuation z-section z-block z-begin z-c">{</span></span></span><span class="z-meta z-function z-c"><span class="z-meta z-block z-c">
</span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c">    <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> memset .bss to zero, and copy .data section to RAM region.
</span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c">    <span class="z-storage z-modifier z-c">extern</span> <span class="z-storage z-type z-c">long</span> _sbss<span class="z-punctuation z-separator z-c">,</span> _ebss<span class="z-punctuation z-separator z-c">,</span> _sdata<span class="z-punctuation z-separator z-c">,</span> _edata<span class="z-punctuation z-separator z-c">,</span> _sidata<span class="z-punctuation z-terminator z-c">;</span>
</span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c">    <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> _sbss et al. are symbols that are located at the start of BSS, etc. So if we
</span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c">    <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> want the address of the start of BSS, we take &_sbss.
</span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c">    <span class="z-keyword z-control z-c">for</span> <span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span><span class="z-storage z-type z-c">long</span> <span class="z-keyword z-operator z-c">*</span>dst <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-keyword z-operator z-c">&</span>_sbss<span class="z-punctuation z-terminator z-c">;</span> dst <span class="z-keyword z-operator z-comparison z-c">&lt;</span> <span class="z-keyword z-operator z-c">&</span>_ebss<span class="z-punctuation z-terminator z-c">;</span> dst<span class="z-keyword z-operator z-arithmetic z-c">++</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span>
</span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c">    <span class="z-meta z-block z-c"><span class="z-punctuation z-section z-block z-begin z-c">{</span>
</span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-meta z-block z-c">        <span class="z-keyword z-operator z-c">*</span>dst <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-constant z-numeric z-integer z-decimal z-c">0</span><span class="z-punctuation z-terminator z-c">;</span>
</span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-meta z-block z-c">    <span class="z-punctuation z-section z-block z-end z-c">}</span></span>
</span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c">    <span class="z-keyword z-control z-c">for</span> <span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span><span class="z-storage z-type z-c">long</span> <span class="z-keyword z-operator z-c">*</span>dst <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-keyword z-operator z-c">&</span>_sdata<span class="z-punctuation z-separator z-c">,</span> <span class="z-keyword z-operator z-c">*</span>src <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-keyword z-operator z-c">&</span>_sidata<span class="z-punctuation z-terminator z-c">;</span> dst <span class="z-keyword z-operator z-comparison z-c">&lt;</span> <span class="z-keyword z-operator z-c">&</span>_edata<span class="z-punctuation z-terminator z-c">;</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span>
</span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c">    <span class="z-meta z-block z-c"><span class="z-punctuation z-section z-block z-begin z-c">{</span>
</span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-meta z-block z-c">        <span class="z-keyword z-operator z-c">*</span>dst<span class="z-keyword z-operator z-arithmetic z-c">++</span> <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-keyword z-operator z-c">*</span>src<span class="z-keyword z-operator z-arithmetic z-c">++</span><span class="z-punctuation z-terminator z-c">;</span>
</span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-meta z-block z-c">    <span class="z-punctuation z-section z-block z-end z-c">}</span></span>
</span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c">    <span class="z-meta z-function-call z-c"><span class="z-variable z-function z-c">main</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function-call z-c"></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span> <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> Call our pitiful main function.
</span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c">
</span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c">    <span class="z-keyword z-control z-c">for</span> <span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span><span class="z-punctuation z-terminator z-c">;</span><span class="z-punctuation z-terminator z-c">;</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span> <span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span><span class="z-storage z-type z-c">void</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span> <span class="z-constant z-numeric z-integer z-decimal z-c">0</span><span class="z-punctuation z-terminator z-c">;</span> <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> Infinite loop
</span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"></span></span><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-punctuation z-section z-block z-end z-c">}</span></span></span>
</span><span class="z-source z-c">
</span><span class="z-source z-c"><span class="z-storage z-modifier z-c">extern</span> <span class="z-storage z-type z-c">void</span> <span class="z-meta z-function z-c"><span class="z-entity z-name z-function z-c">_estack</span></span><span class="z-meta z-function z-parameters z-c"><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function z-parameters z-c"><span class="z-meta z-group z-c"><span class="z-storage z-type z-c">void</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span> <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> Defined in link.ld
</span></span><span class="z-source z-c">
</span><span class="z-source z-c"><span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> 16 standard and 81 STM32L476-specific handlers
</span></span><span class="z-source z-c"><span class="z-meta z-preprocessor z-macro z-c"><span class="z-keyword z-control z-import z-define z-c">#define</span></span><span class="z-meta z-preprocessor z-macro z-c"> <span class="z-entity z-name z-constant z-preprocessor z-c">NUM_PERIPHERAL_INTERRUPTS</span></span><span class="z-meta z-preprocessor z-macro z-c">      <span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span><span class="z-constant z-numeric z-integer z-decimal z-c">81</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span>
</span><span class="z-source z-c"><span class="z-meta z-preprocessor z-macro z-c"><span class="z-keyword z-control z-import z-define z-c">#define</span></span><span class="z-meta z-preprocessor z-macro z-c"> <span class="z-entity z-name z-constant z-preprocessor z-c">NUM_ARM_GENERAL_VECTOR_ENTRIES</span></span><span class="z-meta z-preprocessor z-macro z-c"> <span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span><span class="z-constant z-numeric z-integer z-decimal z-c">16</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span>
</span><span class="z-source z-c">
</span><span class="z-source z-c"><span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> Freakin C function pointer syntax.
</span></span><span class="z-source z-c"><span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> Makes an array of pointers to functions of type void(void)
</span></span><span class="z-source z-c"><span class="z-meta z-attribute z-c"><span class="z-storage z-modifier z-c">__attribute__</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">((</span></span></span><span class="z-meta z-attribute z-c"><span class="z-meta z-group z-c">section<span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span><span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">"</span>.vectors<span class="z-punctuation z-definition z-string z-end z-c">"</span></span><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">))</span></span></span>
</span><span class="z-source z-c"><span class="z-meta z-function-call z-c"><span class="z-variable z-function z-c">void</span> <span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c"><span class="z-keyword z-operator z-c">*</span><span class="z-storage z-modifier z-c">const</span> vector_table<span class="z-meta z-brackets z-c"><span class="z-punctuation z-section z-brackets z-begin z-c">[</span>NUM_ARM_GENERAL_VECTOR_ENTRIES <span class="z-keyword z-operator z-arithmetic z-c">+</span> NUM_PERIPHERAL_INTERRUPTS<span class="z-punctuation z-section z-brackets z-end z-c">]</span></span></span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span><span class="z-storage z-type z-c">void</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span> <span class="z-keyword z-operator z-assignment z-c">=</span> <span class="z-meta z-block z-c"><span class="z-punctuation z-section z-block z-begin z-c">{</span>
</span></span><span class="z-source z-c"><span class="z-meta z-block z-c">    _estack<span class="z-punctuation z-separator z-c">,</span>
</span></span><span class="z-source z-c"><span class="z-meta z-block z-c">    _reset
</span></span><span class="z-source z-c"><span class="z-meta z-block z-c">    <span class="z-comment z-line z-double-slash z-c"><span class="z-punctuation z-definition z-comment z-c">//</span> Of course the rest will be zeros by default. This is okay for now.
</span></span></span><span class="z-source z-c"><span class="z-meta z-block z-c"><span class="z-punctuation z-section z-block z-end z-c">}</span></span><span class="z-punctuation z-terminator z-c">;</span>
</span><span class="z-source z-c">
</span><span class="z-source z-c"><span class="z-storage z-type z-c">int</span> <span class="z-meta z-function z-c"><span class="z-entity z-name z-function z-c">main</span></span><span class="z-meta z-function z-parameters z-c"><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function z-parameters z-c"><span class="z-meta z-group z-c"><span class="z-storage z-type z-c">void</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-meta z-function z-c">
</span></span><span class="z-source z-c"><span class="z-meta z-function z-c"></span><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-punctuation z-section z-block z-begin z-c">{</span></span></span><span class="z-meta z-function z-c"><span class="z-meta z-block z-c">
</span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c">    <span class="z-keyword z-control z-flow z-return z-c">return</span> <span class="z-constant z-numeric z-integer z-decimal z-c">0</span><span class="z-punctuation z-terminator z-c">;</span>
</span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"></span></span><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-punctuation z-section z-block z-end z-c">}</span></span></span>
</span></code></pre><p><strong>link.ld</strong>:<pre class=z-code><code><span class="z-text z-plain">ENTRY(_reset);
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">MEMORY {
</span><span class="z-text z-plain">    flash(rx) : ORIGIN = 0x08000000, LENGTH = 1024k /* 1 Mbyte of flash */
</span><span class="z-text z-plain">    sram(rwx) : ORIGIN = 0x20000000, LENGTH = 96k /* SRAM1 */
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">    /* SRAM2, has hardware parity check, can be retained in standby mode */
</span><span class="z-text z-plain">    /*sram2(rwx): ORIGIN = 0x10000000, LENGTH = 32k */
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">    _estack = ORIGIN(sram) + LENGTH(sram); /* Stack points to very end of sram */
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">SECTIONS {
</span><span class="z-text z-plain">    .vectors : { KEEP(*(.vectors)) } > flash
</span><span class="z-text z-plain">    .text    : { *(.text*) }         > flash
</span><span class="z-text z-plain">    .rodata  : { *(.rodata*) }       > flash
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">    .data : {
</span><span class="z-text z-plain">        _sdata = .; /* data section start */
</span><span class="z-text z-plain">        *(.first_data)
</span><span class="z-text z-plain">        *(.data SORT(.data.*))
</span><span class="z-text z-plain">        _edata = .; /* data section end */
</span><span class="z-text z-plain">    } > sram AT > flash
</span><span class="z-text z-plain">    _sidata = LOADADDR(.data);
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">    .bss : {
</span><span class="z-text z-plain">        _sbss = .; /* bss section start */
</span><span class="z-text z-plain">        *(.bss SORT(.bss.*) COMMON)
</span><span class="z-text z-plain">        _ebss = .; /* bss section end */
</span><span class="z-text z-plain">    } > sram
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">    . = ALIGN(8);
</span><span class="z-text z-plain">    _end = .; /* for cmsis_gcc.h */
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">    /* I've got a lot to learn about linker scripts, honey. */
</span></code></pre><p>And the build command:<pre class="language-sh z-code" data-lang=sh><code class=language-sh data-lang=sh><span class="z-source z-shell z-bash"><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">arm-none-eabi-gcc</span></span><span class="z-meta z-function-call z-arguments z-shell"><span class="z-variable z-parameter z-option z-shell"><span class="z-punctuation z-definition z-parameter z-shell"> -</span>T</span> link.ld<span class="z-variable z-parameter z-option z-shell"><span class="z-punctuation z-definition z-parameter z-shell"> -</span>nostdlib</span> main.c<span class="z-variable z-parameter z-option z-shell"><span class="z-punctuation z-definition z-parameter z-shell"> -</span>o</span> firmware.elf</span>
</span></code></pre><p>And then making the binary to be flashed:<pre class="language-sh z-code" data-lang=sh><code class=language-sh data-lang=sh><span class="z-source z-shell z-bash"><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">arm-none-eabi-objcopy</span></span><span class="z-meta z-function-call z-arguments z-shell"><span class="z-variable z-parameter z-option z-shell"><span class="z-punctuation z-definition z-parameter z-shell"> -</span>O</span> binary firmware.elf firmware.bin</span>
</span></code></pre><p>And then the flash command:<pre class="language-sh z-code" data-lang=sh><code class=language-sh data-lang=sh><span class="z-source z-shell z-bash"><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">st-flash</span></span><span class="z-meta z-function-call z-arguments z-shell"><span class="z-variable z-parameter z-option z-shell"><span class="z-punctuation z-definition z-parameter z-shell"> --</span>reset</span> write firmware.bin 0x8000000</span>
</span></code></pre><p>And success!<p>I wonder if making the output format of <code>arm-none-eabi-objcopy</code> <code>binary</code> is what made it all work... I was making Intel <code>.hex</code> files before, and they didn't seem to work very well.... I can't remember what source I was following to do that. IIRC ST-Link should be able to handle a variety of formats, but maybe a flat binary image is best. You should be able to just write that to the flash as-is, I would think.<p>In fact, let's go one step further and look at it closely:<p><strong>firmware.bin</strong>:<pre class=z-code><code><span class="z-text z-plain">00000000: 0080 0120 8401 0008 0000 0000 0000 0000  ... ............
</span><span class="z-text z-plain">00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span><span class="z-text z-plain">00000020: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span><span class="z-text z-plain">00000030: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span><span class="z-text z-plain">00000040: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span><span class="z-text z-plain">00000050: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span><span class="z-text z-plain">00000060: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span><span class="z-text z-plain">00000070: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span><span class="z-text z-plain">00000080: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span><span class="z-text z-plain">00000090: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span><span class="z-text z-plain">000000a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span><span class="z-text z-plain">000000b0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span><span class="z-text z-plain">000000c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span><span class="z-text z-plain">000000d0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span><span class="z-text z-plain">000000e0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span><span class="z-text z-plain">000000f0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span><span class="z-text z-plain">00000100: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span><span class="z-text z-plain">00000110: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span><span class="z-text z-plain">00000120: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span><span class="z-text z-plain">00000130: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span><span class="z-text z-plain">00000140: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span><span class="z-text z-plain">00000150: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span><span class="z-text z-plain">00000160: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span><span class="z-text z-plain">00000170: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span><span class="z-text z-plain">00000180: 0000 0000 5040 9fe5 0200 00ea 0030 a0e3  ....P@.......0..
</span><span class="z-text z-plain">00000190: 0030 84e5 0440 84e2 4030 9fe5 0300 54e1  .0...@..@0....T.
</span><span class="z-text z-plain">000001a0: f9ff ff3a 3840 9fe5 3850 9fe5 0500 00ea  ...:8@..8P......
</span><span class="z-text z-plain">000001b0: 0520 a0e1 0450 82e2 0430 a0e1 0440 83e2  . ...P...0...@..
</span><span class="z-text z-plain">000001c0: 0020 92e5 0020 83e5 1c30 9fe5 0300 54e1  . ... ...0....T.
</span><span class="z-text z-plain">000001d0: f6ff ff3a 0500 00eb feff ffea 0000 0020  ...:...........
</span><span class="z-text z-plain">000001e0: 0000 0020 0000 0020 0c02 0008 0000 0020  ... ... .......
</span><span class="z-text z-plain">000001f0: 04b0 2de5 00b0 8de2 0030 a0e3 0300 a0e1  ..-......0......
</span><span class="z-text z-plain">00000200: 00d0 8be2 04b0 9de4 1eff 2fe1            ........../.
</span></code></pre><p>Yeah, that looks exactly like what I would expect. The initial stack pointer in little endian, followed by the pointer to <code>_reset()</code> in little endian, then a whole bunch of 0 pointers, followed by our code at 0x0000 0184, which will be mapped to 0x0800 0184 when this is written to flash. Sweet!<p>Let's adapt the Makefile from the bare metal programming tutorial to match our project directory.<h1 id=blinking-an-led><a aria-label="Anchor link for: blinking-an-led" class="header-anchor no-hover-padding" href=#blinking-an-led><span aria-hidden=true class=link-icon></span></a> Blinking an LED</h1><p>Okay, let's set up the GPIO registers as shown in the "STM32L47xxx, STM32L48xxx, STM32L49xxx and STM32L4Axxx" reference manual.<h2 id=gpio-ports><a aria-label="Anchor link for: gpio-ports" class="header-anchor no-hover-padding" href=#gpio-ports><span aria-hidden=true class=link-icon></span></a> GPIO Ports</h2><p>GPIO pins are grouped by <strong>ports</strong>. My current understanding is it's simply a means of grouping pins togeher, although I'm sure there is more to it.<p>You'll have to look at the documentation on how to enable GPIO pins. It's pretty typical to have to do the following:<ul><li>maybe enable or power the GPIO port. <ul><li>In STM32s, and maybe others, this can be enabled by "clocking" it via the RCC.</ul><li>enable GPIO mode in the MODER of the GPIO port you're using</ul><h1 id=troubleshooting><a aria-label="Anchor link for: troubleshooting" class="header-anchor no-hover-padding" href=#troubleshooting><span aria-hidden=true class=link-icon></span></a> Troubleshooting</h1><h2 id=clocking-problems><a aria-label="Anchor link for: clocking-problems" class="header-anchor no-hover-padding" href=#clocking-problems><span aria-hidden=true class=link-icon></span></a> Clocking Problems</h2><p>Trouble with getting anything to work? Have you plugged in a debugger and seen your write commands to peripheral registers have no effect whatsoever? You probably don't have the right clock set up. Make sure:<ol><li>That you have a clock enabled<li>That you have the peripheral clock enabled.</ol><p>These steps are especially important for devices meant for low power, cause they tend not to start them by default to save juice.<h2 id=memory-offset-errors><a aria-label="Anchor link for: memory-offset-errors" class="header-anchor no-hover-padding" href=#memory-offset-errors><span aria-hidden=true class=link-icon></span></a> Memory Offset Errors</h2><p><em><strong>CHECK THE GIVEN OFFSETS!</strong></em> Just because one register comes right after another in a datasheet, you cannot assume they are contiguous.<h2 id=i-ve-combed-over-this-code-20-times-and-i-don-t-see-anything-wrong><a aria-label="Anchor link for: i-ve-combed-over-this-code-20-times-and-i-don-t-see-anything-wrong" class="header-anchor no-hover-padding" href=#i-ve-combed-over-this-code-20-times-and-i-don-t-see-anything-wrong><span aria-hidden=true class=link-icon></span></a> I've combed over this code 20 times and I don't see anything wrong</h2><p>First, <em><strong>Check if your spin function is taking too long.</strong></em> Turns out I grossly underestimated how long each one of those cycles would take. This code has been working for much longer than I gave it credit for.<p>Second, take a break. Come back and look at it tomorrow. Fresh eyes see a lot.<p>Sincerely,<p>Most of my Saturday<h1 id=documentation-you-ll-need-for-bare-metal-programming><a aria-label="Anchor link for: documentation-you-ll-need-for-bare-metal-programming" class="header-anchor no-hover-padding" href=#documentation-you-ll-need-for-bare-metal-programming><span aria-hidden=true class=link-icon></span></a> Documentation you'll need for bare metal programming</h1><p>I truly believe documentation is one of the biggest factors in the success of a project. If it's easy to find out answers to your questions and to browse through available material so you pick up new knowledge and tricks, you're golden. Too often, though, and <strong>especially</strong> with embedded devices, the documentation you need is just not to be found, or worse: is available, but hasn't been provided to you.<h2 id=what-you-ll-need><a aria-label="Anchor link for: what-you-ll-need" class="header-anchor no-hover-padding" href=#what-you-ll-need><span aria-hidden=true class=link-icon></span></a> What you'll need</h2><p>This is my best guess for what to look for.<ul><li>Your dev board will have its own documentation. You're probably looking for a user guide or manual and a brochure. <ul><li>The user guide will tell you <strong>how the peripherals are hooked up on the board</strong>. It answers questions like, "Which pin is this LED connected to?", "Which SPI bus talks to this sensor on the dev kit?", and "Which UART is piped to the USB cable?" You'll want this.<li>The brochure is less useful, but it can be a faster way to answer questions that are either a) not answered in the dev kit user guide, and/or b) are included on the two or so pages of the brochure. Best for answering questions like "how much flash do I have on this chip again?" or "How much RAM is there?" or, "Is there an external flash chip too, or am I just using on-chip flash?"</ul><li>There will be a technical document, probably about 60-200 pages, on the specific processor you have on your dev kit. Be sure you're looking at the exact right datasheet. <em><strong>Do not assume similarities between chips of the same family</strong></em>. It will just make you sad. This document tells you some specifics about the peripherals on <em>your specific chip</em>. The catch? It usually doesn't include enough detail to help you actually program any of the peripherals.<li>There will usually be another technical document, probably over 1000 pages, on the family of processors you have. This will have a lot of the details that were missing from your model-specific manual. It will have details like, "What does the GPIO MODER register look like?" and "What clocks do I need to configure and how do I do that?".<li><em>Optional</em>: You might find a bunch of Application Notes. These are technical documents that give you the math, theory, and sometimes circuits and code you need to accomplish different tasks, like connect over Bluetooth or capture from a microphone or something. They can be full of useful information, mostly if you're in one of three camps: <ul><li>You'd like to do the thing talked about in the app note<li>You'd like to learn more about the hardware you have<li>You'd like to learn more about embedded engineering in general. App notes often contain useful theory and start from an assumption of general engineering knowledge.</ul></ul><h3 id=less-useful-resources><a aria-label="Anchor link for: less-useful-resources" class="header-anchor no-hover-padding" href=#less-useful-resources><span aria-hidden=true class=link-icon></span></a> Less useful resources</h3><p>Note that what you're <strong>not</strong> <em><strong>usually</strong></em> looking for are things that apply to all Cortex-M processors or Cortex-M4s or M33s or whathaveyou. Those docs from ARM are more focused on the architecture of their family of Cortex processors: pipelines, assembly instructions, that sort of thing. Remember that ARM provides the computation core designs and silicon manufacturers actually design, layout, fab, and document the chips you're using. This includes all the peripherals, like GPIO, I2C, and ADCs. Most of the time as an embedded dev you'll be dealing with peripherals, the manufacturer-specific parts.<p>However, sometimes you do need to reference something that is common to all Cortex-Ms or something like that. The first thing I would do is look for what architecture your chip uses. For example, Cortex-M4s use the ARMv7-M architecture, so I look for the <a href="https://developer.arm.com/documentation/ddi0403/ee/?lang=en" rel=noopener target=_blank>ARMv7-M Architecture Reference manual</a> to find documentation on things like SysTick.<p>Honestly, though, if you want to learn what's common between different processor families or groups ("Is this feature on all Cortex-M0s?"), Wikipedia will be a faster resource for learning than combing datasheets.<h2 id=documents-recap><a aria-label="Anchor link for: documents-recap" class="header-anchor no-hover-padding" href=#documents-recap><span aria-hidden=true class=link-icon></span></a> Documents Recap</h2><p>So that's your task. When you're trying to program something, try to get those three or so documents:<ul><li>Dev board user manual<li>Model-specific manual<li>Manufacturer family specific manual with all the juicy details<li>As a precaution, just save every applicable PDF you come across in your journey. (But for heaven's sake, try to organize them somewhat). It's way easier than trying to re-find that one PDF you remember coming across once upon a time. Trust me.</ul><h1 id=results><a aria-label="Anchor link for: results" class="header-anchor no-hover-padding" href=#results><span aria-hidden=true class=link-icon></span></a> Results</h1><p>In the end, I was able to tune the wait function well enough to get some blinking action going! Behold, in all its glory, the entirely manually-programmed blinkenlight:</p><img src=../../img/articles/bare-metal-arm-programming/blinking-stm32.gif></section></article></main><span class=hidden id=copy-success> Copied! </span><span class=hidden id=copy-init> Copy code to clipboard </span><script defer src=https://tristanandrus.com/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" href=https://tristanandrus.com/atom.xml rel=noopener target=_blank> <img alt=feed loading=lazy src=https://tristanandrus.com/social_icons/rss.svg title=feed> </a><li><a class="nav-links no-hover-padding social" rel="noopener me" href=https://github.com/steelswords/ target=_blank> <img alt=github loading=lazy src=https://tristanandrus.com/social_icons/github.svg title=github> </a><li><a class="nav-links no-hover-padding social" rel="noopener me" href=https://www.linkedin.com/in/tristan-andrus target=_blank> <img alt=linkedin loading=lazy src=https://tristanandrus.com/social_icons/linkedin.svg title=linkedin> </a><li><a class="nav-links no-hover-padding social" rel="noopener me" href=https://fosstodon.org/@steelswords target=_blank> <img alt=mastodon loading=lazy src=https://tristanandrus.com/social_icons/mastodon.svg title=mastodon> </a><li><a class="nav-links no-hover-padding social" rel="noopener me" href=https://bsky.app/profile/steelswords.bsky.social target=_blank> <img alt=bluesky loading=lazy src=https://tristanandrus.com/social_icons/bluesky.svg title=bluesky> </a></ul></nav><nav class=nav-navs></nav><div class=credits><small> Powered by <a href=https://www.getzola.org rel=noopener target=_blank>Zola</a> & <a href=https://github.com/welpo/tabi rel=noopener target=_blank>tabi</a> </small></div></section></footer>